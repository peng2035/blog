<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于spring中代理的相关问题]]></title>
    <url>%2F2018%2F01%2F03%2F%E5%85%B3%E4%BA%8Espring%E4%B8%AD%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[spring代理问题问题还是起于老掉牙的spring @Transactional 同类调用不生效的问题。以下的场景都基于method1调用method2，@Transactional 是加载method2上，外部调用调用的是method1接口。大致结构如下 12345678910public void method1() &#123; System.out.println("do in method 1"); method2();&#125;@Transactionalpublic void method2() &#123; System.out.println("do in method 2");&#125; 以前一直对于这个问题懵懵懂懂，现在彻底的来搞明白这个事情。 疑问对于jdk动态代理，其实问题一直很明白，因为jdk动态代理生成的proxy是继承自java.lang.reflect.Proxy，反射到目标类去执行，而在目标类的内部调用中是无法再回到代理类的，所以 @Transactional 在同类调用之间无效。 但是cglib生成的是目标类的子类，猜想的结构大概是这样的。1234567891011121314151617181920212223242526272829303132//猜想的cglib生成类简易写法public class GuessedCglibProxy extends SimpleCglibService &#123; @Override public void method1() &#123; System.out.println("GuessedCglibProxy in method1"); super.method1(); &#125; @Override public void method2() &#123; System.out.println("GuessedCglibProxy in method2"); super.method2(); &#125;&#125;public class SimpleCglibService &#123; public void method1() &#123; System.out.println("SimpleCglibService in method1"); method2(); &#125; public void method2() &#123; System.out.println("SimpleCglibService in method2"); &#125; public static void main(String[] args) &#123; GuessedCglibProxy guessedCglibProxy = new GuessedCglibProxy(); guessedCglibProxy.method1(); &#125;&#125; 这样理论上应该是能够调用到代理类的。但是事实是并不能调用成功。找了一下Spring文档也发现了相关的结论。 Note: In proxy mode (which is the default), only ‘external’ method calls coming in through the proxy will be intercepted. This means that ‘self-invocation’, i.e. a method within the target object calling some other method of the target object, won’t lead to an actual transaction at runtime even if the invoked method is marked with @Transactional! Consider the use of AspectJ mode (see below) if you expect self-invocations to be wrapped with transactions as well. In this case, there won’t be a proxy in the first place; instead, the target class will be ‘weaved’ (i.e. its byte code will be modified) in order to turn @Transactional into runtime behavior on any kind of method. 重新梳理一下知识点。那么究竟问题在哪。 jdk动态代理jdk动态代理调用栈 jdk动态代理demo代码测试代码地址 先看下简易的动态代理的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public interface SimpleService &#123; void method1(); void method2();&#125;public class SimpleServiceImpl implements SimpleService &#123; @Override public void method1() &#123; System.out.println("do in method 1"); method2(); &#125; @Override public void method2() &#123; System.out.println("do in method 2"); &#125; public static void main(String[] args) &#123; //生成jdk动态代理的方法 ProxyUtils.generateClassFile(SimpleService.class, "SimpleServiceJavaDynamicProxy"); SimpleService simpleService = new SimpleServiceImpl(); SimpleService simpleServiceImpl = SimpleServiceProxy.proxy(SimpleService.class, simpleService); simpleServiceImpl.method1(); &#125;&#125;public class SimpleServiceProxyHandler implements InvocationHandler &#123; //invoke 方法并不提供impl的实例，因为proxy在生成的时候是与impl无关的，所以这里需要自己塞进去 private Object target; public SimpleServiceProxyHandler(Object target) &#123; this.target = target; &#125; // 方法需要自定义 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("in proxy, class : " + target.getClass().getName() + " ,method : " + method.getName()); return method.invoke(target, args); &#125;&#125;public class SimpleServiceProxy &#123; //构建代理类，详细分析下面会有 public static &lt;T&gt; T proxy(final Class&lt;T&gt; interfaceClass, T target) &#123; return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[]&#123;interfaceClass&#125;, new SimpleServiceProxyHandler(target)); &#125;&#125;public class ProxyUtils &#123; // 动态代理类落地的方法。 // 一般都是在target同类的目录下 public static void generateClassFile(Class clazz,String proxyName)&#123; byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces()); String paths = clazz.getResource(".").getPath(); System.out.println(paths); FileOutputStream out = null; try &#123; out = new FileOutputStream(paths+proxyName+".class"); out.write(classFile); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Jdk动态代理的生成类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public final class SimpleServiceJavaDynamicProxy extends Proxy implements SimpleService &#123; private static Method m1; private static Method m2; private static Method m4; private static Method m3; private static Method m0; public SimpleServiceJavaDynamicProxy(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void method2() throws &#123; try &#123; super.h.invoke(this, m4, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void method1() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]&#123;Class.forName("java.lang.Object")&#125;); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m4 = Class.forName("com.bobby.peng.learning.java.proxy.javadynamicproxy.SimpleService").getMethod("method2", new Class[0]); m3 = Class.forName("com.bobby.peng.learning.java.proxy.javadynamicproxy.SimpleService").getMethod("method1", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 由于动态代理的class继承了proxy，所以jdk动态代理必须要有接口。 super.h.invoke 其实调用的是InvocationHandler的方法，自己实现，一般是method.invoke(targetClass,args)，所以在targetClass内部调用的话，是不会走到代理类的，故@Transactional会失效。 更加深入的了解一下jdk动态代理先看下newProxyInstance方法整个逻辑其实很简单，获得proxy的class，然后构造proxy实例。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; // 校验部分 Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; // 获取proxy的class（包括构造） /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 构造对象 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 其中关键节点是getProxyClass0方法，下面是一整条调用链。通过接口可以发现，proxy class 仅仅与 classloader 和 interface 有关所以在继承InvocationHandler的时候，impl的实例是不存在的。仅仅只有proxy的实例。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* * Look up or generate the designated proxy class. */Class&lt;?&gt; cl = getProxyClass0(loader, intfs);/** * Generate a proxy class. Must call the checkProxyAccess method * to perform permission checks before calling this. */private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces);&#125;/** * Look-up the value through the cache. This always evaluates the * &#123;@code subKeyFactory&#125; function and optionally evaluates * &#123;@code valueFactory&#125; function if there is no entry in the cache for given * pair of (key, subKey) or the entry has already been cleared. * * @param key possibly null key * @param parameter parameter used together with key to create sub-key and * value (should not be null) * @return the cached value (never null) * @throws NullPointerException if &#123;@code parameter&#125; passed in or * &#123;@code sub-key&#125; calculated by * &#123;@code subKeyFactory&#125; or &#123;@code value&#125; * */// weak cache 源代码// 在proxy中 key : classloader ,parameter : interfacespublic V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); // 清除已经被回收的weak reference map中的value值，在weak reference部分会有源码 expungeStaleEntries(); // 这里的cache key是一个weak reference 的 key // 关于weak reference 下文会有论述 // refQueue 的作用同样也在weak reference中阐述 Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey // map的第一层仅仅与classloader有关 // 我感觉这一层map的区分度不是很高，不如直接就采用一层map，直接用里面一层的，classloader和interface直接组成一个key // 外层是weak reference的key，意味着一旦被回收，该classloader所有的proxy就会被回收，感觉不太合理（todo 仔细想想） ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); // 参考 putIfAbsent 方法 return 说明 // return null的时候说明put的时候是absent的，如果不为null，说明有并发场景存在 // 外层判定是保证效率，内层判空是防止并发 if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap // subKeyFactory.apply 构建的时候是通过parameter 也就是 接口来实现的 // key 也就是 classloader 并没有用到 // 也就是说 subkey 仅仅是接口相关而与实现类无关 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance // 下文会有分析 V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // lazily construct a Factory if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125; &#125; supplier might be a Factory or a CacheValue instance关于这句注释，当时看代码的时候有点奇怪，当时以为是简单的get，现在看来get都不是简单的get。 TAT Factory相关1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Overridepublic synchronized V get() &#123; // serialize access // re-check Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop // 防止多线程发生，因为在get外部不是同步的 return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; // 这里的apply生成真正的proxy.class 文件 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) // 构造valuemaps的新对象 CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // try replacing us with CacheValue (this should always succeed) // replace牛逼啊！还是default的有木有啊！还是cas的卧槽！ if (valuesMap.replace(subKey, this, cacheValue)) &#123; // put also in reverseMap // reverse Map 感觉用Set会更好，因为塞入的值都是true // 而且只有在size和containsValue才有用 reverseMap.put(cacheValue, Boolean.TRUE); &#125; else &#123; throw new AssertionError("Should not reach here"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value;&#125; 这里同步get的理由应该是要防止并发，并降低锁的粒度，否则锁的粒度应该构建整个map的时候就开始了。proxy生成的代码比较复杂就不看了 在构建类发现一行这个代码，也就是说只要将saveGeneratedFiles设为true就会生成proxy.class在硬盘上。 123456789101112131415161718192021222324private static final boolean saveGeneratedFiles = ((Boolean)AccessController.doPrivileged(new GetBooleanAction("sun.misc.ProxyGenerator.saveGeneratedFiles"))).booleanValue();if(saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if(var1 &gt; 0) &#123; Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar), new String[0]); Files.createDirectories(var3, new FileAttribute[0]); var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class"); &#125; else &#123; var2 = Paths.get(var0 + ".class", new String[0]); &#125; Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError("I/O exception saving generated file: " + var4x); &#125; &#125; &#125;);&#125; 默认在项目根目录下有个com.sun.xxx下就会出现proxy.class文件。不用单独的去写utils类了，以下是开启方法。1System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); 关于 weak reference 简单的理解 //todo 详细了解weak reference 对象被创建之后，如果没有任何引用指向他，且发生gc，则对象则会被消失。 如果引用的该对象的是一个集合，我们经常会在 代码中看到 node = null;//help gc 这样的代码来帮助gc。 但是cache是例外的，因为cache不知道他的生命周期是怎么样的，比如我们在使用redis的时候我们并不知道这个key应该存在多久，什么时候会被停止使用，是否够热。 那么cache的普通做法是lru或者lfu，来保证cache中的数据是最有效的。而内存中的cache一般不会那么做（redis有内存大小的限制），因为我们无法估算大小，且在系统允许的情况下存的越多越好。 而在上述proxy的使用场景下，一个interface下大概率也只用proxy.class一次（比如单例的service），而我们项目假设有1000个需要动态代理的class，那么在cache中的也有1000个对象，可能大部分是无效的，占用了大部分内存。 因为我们无法知晓cache的生命周期，所以 node = null; //help gc 这样的代码显然不适合我们。 所以weak reference的意义就在这里，当且仅当一个对象被weak reference指向时，gc时就被回收。 因为weak reference 是随着gc被回收，所以他的回收是具有不确定性的，一般用于易构建但是占用内存较大的对象。 代码中会看到清空ReferenceQueue，这里保存的是已经被回收的weak reference，因为weak reference本身是没有用的。 下面代码是关于weak reference的回收 123456789101112131415161718192021private void expungeStaleEntries() &#123; CacheKey&lt;K&gt; cacheKey; while ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != null) &#123; //在weak reference的对象被回收之后，weak reference本身和map中的数据需要一并的清空 cacheKey.expungeFrom(map, reverseMap); &#125;&#125;void expungeFrom(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map, ConcurrentMap&lt;?, Boolean&gt; reverseMap) &#123; // removing just by key is always safe here because after a CacheKey // is cleared and enqueue-ed it is only equal to itself // (see equals method)... ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(this); // remove also from reverseMap if needed if (valuesMap != null) &#123; for (Object cacheValue : valuesMap.values()) &#123; reverseMap.remove(cacheValue); &#125; &#125;&#125; cglib动态代理]]></content>
      <tags>
        <tag>java</tag>
        <tag>复习</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例的N种写法]]></title>
    <url>%2F2017%2F12%2F18%2F%E5%8D%95%E4%BE%8B%E7%9A%84N%E7%A7%8D%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112public class Singleton1 &#123; private static Singleton1 singleton = null; private Singleton1() &#123;&#125; public static Singleton1 newInstance() &#123; if(singleton == null) &#123; singleton = new Singleton1(); &#125; return singleton; &#125;&#125; 优点：惰性加载缺点：多线程有问题 123456789101112public class Singleton2 &#123; private static Singleton2 singleton = null; private Singleton2() &#123;&#125; public synchonized static Singleton2 newInstance() &#123; if(singleton == null) &#123; return new Singleton2(); &#125; return singleton; &#125;&#125; 优点：多线程问题解决缺点：newInstance 阻塞 12345678910111213141516public class Singleton3 &#123; private static Singleton3 singleton = null; privte Singleton3() &#123;&#125; public static Singleton3 newInstance() &#123; if(singleton == null) &#123; synchonized(this.class) &#123; if(singleton == null) &#123; return new Singleton3(); &#125; &#125; &#125; return singleton; &#125;&#125; 优点：性能提升，不会再newInstance阻塞。缺点：线程安全有问题，new Singleton3()在指令重排序的情况下，可能只生成了半个对象。详解 12345678910111213141516public class Singleton4 &#123; private static volatile Singleton4 singleton = null; private Singleton4() &#123;&#125; public Singleton4 newInstance() &#123; if(singleton == null) &#123; sychonized(this.class) &#123; if(singleton == null) &#123; return new Singleton4(); &#125; &#125; &#125; return singleton; &#125;&#125; 优点：线程安全解决，性能可行，推荐缺点：写起来麻烦。 123456789public class Singleton5 &#123; private static Singleton5 singleton = new Singleton5(); private Singleton5() &#123;&#125; public static newInstance() &#123; return singleton; &#125;&#125; 优点：写起来简单，线程安全（classload）机制保证。缺点：在Singleton5被加载时 实例就已经被初始化了。1234private static Singleton5 singleton = null;static &#123; singleton = new Singleton5():&#125; 同理 123public enum Singleton6 &#123; SINGLETON;&#125; 优点：写法简单清晰，线程安全，effective java隆重推荐，不会因为序列化和反序列话新增对象缺点：不能实现懒加载 12345678910111213public class Singleton7 &#123; private static class SingletonHolder() &#123; private static final Singleton7 singleton = new Singleton7(); private SingletonHolder() &#123;&#125; &#125; private Singleton7() &#123;&#125; public Singleton7 newInstance() &#123; return SingletonHolder.singleton; &#125;&#125; 优点：间接实现了懒加载，因为在singleton加载的时候，SingletonHolder并不会被实例化。 实现方式 关键点 资源浪费 线程安全 多线程环境的性能足够优化 基础饱汉 懒加载 否 否 - 饱汉变种1 懒加载、同步 否 是 否 饱汉变种2 懒加载、DCL 否 否 - 饱汉变种3 懒加载、DCL、volatile 否 是 是 饿汉 静态变量初始化 是 是 是 Holder 静态变量初始化、holder 否 是 是 枚举 枚举本质、静态变量初始化 否 是 是 参考单例模式有几种写法 如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。 123456789private static Class getClass(String classname) throws ClassNotFoundException &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if(classLoader == null) classLoader = Singleton.class.getClassLoader(); return (classLoader.loadClass(classname)); &#125; &#125; 如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。 12345678910public class Singleton implements java.io.Serializable &#123; public static Singleton INSTANCE = new Singleton(); protected Singleton() &#123; &#125; private Object readResolve() &#123; return INSTANCE; &#125; &#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL一些使用技巧与总结]]></title>
    <url>%2F2017%2F09%2F20%2FSQL%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于mysql的一些建议数据类型 更小的通常更好。 更小的数据类型通常更快，因为他们占用更少的磁盘，内存和CPU缓存，并且处理时需要的CPU周期也更少。 确保没有低估需要存储的值的范围，因为在schema中的多个地方增加数据类型的范围是一个非常耗时和痛苦的操作。 例：类似status字段就可以使用 tinyint unsigned，id 字段可以使用 bigint unsigned 选择更加合适的数据类型 不同的数据类型可能会在使用时引起歧义（例：时间可以用bigint，可以用datetime，可以用字符串，但是使用datetime不会引起歧义）。 字符串在排序规则和字符集上比整型时间等更加复杂。 char与varchar varchar是变长的数据类型，仅使用必要的数据空间，同时需要额外的空间存储长度。在数据产生变更时，容易产生页分裂。 varchar不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率 char是定长的数据类型，占用的空间会更大，但是不易产生碎片。会截取字符串最后的空格。 char适合存储非常短的字符串，或者长度几乎一致的字符串（md5）。而varchar则能满足大部分的要求。 引申：那么varchar(200)和varchar(5)区别在哪呢~ varchar在硬盘中是变长，而读取到内存则是定长，临时表同理，200的长度无疑更消耗性能。 索引 最左匹配原则，mysql会一直向右匹配直到遇到范围查询（&gt;,&lt;,between,like）就停止匹配。 例：a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整 线上遇到过同时建立(a,b,c)和（a,b）索引的，根据最左匹配原则，(a,b,c)已经能满足（a,b）的查询需求，所以(a,b)是有些多余的。如果之前是(a,b)的索引，仅需扩充成(a,b,c)即可，不需要新建索引。 范围查找的字段尽量放在索引的最后，详见第一条，c放在最后可以被有效的利用到，且不会阻塞被精确匹配的列。 严禁左模糊或者全模糊 = 和 in 可以乱序。 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 尽可能的选择区分度高的列作为索引。 区分度越高，扫描的记录越少，原理见B-Tree 区分度公式：count(distinct col)/count(*)详见下文 越接近1区分度越高。尽量高于0.1。 关于status 如果查询的频度很高，建议将status这类的枚举字段作为前缀。即使查询用不到，可以穷举，类似status in (1,2,3,4) &amp; a = 1 &amp; b = 2，上述前提是status覆盖度很高，且查询量很大，如果status大部分时候仅作为状态记录，则不建议用此方式。 索引列不能参与计算 比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’) 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 唯一索引的查找效率非常高，且能防止脏数据的产生。 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致;多表关联查询 时，保证被关联的字段需要有索引。 即使双表 join 也要注意表索引、SQL 性能。 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%以上。 就是再加一列，作为Varchar的指纹列，可以用hash或者MD5，然后在指纹列上加索引，查询的时候可以用 where hash = ? and string = ?，同样可以适用于text。（针对前N个字段区分度不是很高的列可以使用这种方式，但是有一定的侵入性） 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 正例：where a=? and b=? order by c; 索引:a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如:WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。 利用覆盖索引来进行查询操作，避免回表。 覆盖索引（covering index）指一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。也可以称之为实现了索引覆盖。 聚簇索引 的数据是放置在叶子节点的，如果要走到叶子节点还需要硬盘的io操作，效率低。 说明 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。 利用延迟关联或者子查询优化超多分页场景。 MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 优化方案：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 最好给分页加个限制，例如超过500页就不能查询了，数据量大的话建议走搜索引擎。 sql相关 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。 当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。 可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 感谢文兵大哥的意见参考阿里巴巴开发手册，高性能mysql]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[in ximalaya]]></title>
    <url>%2F2017%2F07%2F09%2Fin-ximalaya%2F</url>
    <content type="text"><![CDATA[感谢 感谢曾经帮助过我的喜马拉雅的小伙伴们。 感谢ted &amp; mandy领进门，两位的面试至今难忘，也促使我去学习了很多知识，非常感谢两位大神。 感谢rudy &amp; changming，虽然理念上可能是背道而驰，很多事情的处理上也不能苟同，但是还是指导我入门了分布式系统，DDD。 感谢曾大神 &amp; riven &amp; 峰哥，刚入职的好伙伴，感谢各位在业务和技术上方方面面的帮助，祝曾大神有越来越多的小姐姐，riven和峰哥更上一层楼吧~ 感谢单大，zhiting，我知道我的bug还是挺多的，业务感谢还是很不熟的TAT，感谢两位的包容&amp;cola，祝两位节节高升，嘻嘻。 感谢磊大，磊大的工作总是那么的block，给我上班时间学习提供了可能。祝磊大有一个能为其安排工作的后端码农~ 感谢金大，犹记得那次接口参数改了在hudson上导致的坑爹问题，感谢金大的包容，金大腿长1米8。 感谢兵大，每次和兵大对话感觉智商都被碾压，兵大都技术的理解和思考都非常深入，道标型人物~ 感谢yuanwhy &amp; 琛总，基础服务组的两位大哥，组内栋梁，交流的也比较多，两位高升之后也请带上小弟~ 感谢big ben，让我知道如何用手机逛gitlab，然后让我去修一下bug。 感谢rick，fred，鸿贵，陈杨，小宇，dylan 还有很多很多，感谢大家的帮助和支持。 感谢sunsun，至于为什么要谢，我完全不知道，巴特感觉还是要谢一下，巴结一下支付宝的总没错。（听说感谢一下会送我一个蚂蚁宝宝） 未来从xima离职两个月了，感觉自己颓废了很多，感觉要被兵哥 金大 yuanwhy &amp; 琛总这些曾经的小伙伴远远的甩在后面了，期间也看了不少理论性的闲书，感觉是时候动一动手，整理一下，重新做一些有趣的东西了。 作为一个全组最菜的咸鱼也是有梦想的~ finallyAugust is coming ! welcome to hz ! ToB is the best~]]></content>
      <tags>
        <tag>ximalaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[concurrent 常用类]]></title>
    <url>%2F2017%2F03%2F31%2Fconcurrent-%E5%B8%B8%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Concurrent 常用类(未完待续) （基于java 1.8）BlockQueue 四种形式 抛出异常 返回一个特殊值(可能是null或者是false，取决于具体的操作) 阻塞当前执行直到其可以继续 当线程被挂起后，等待最大的时间，如果一旦超时，即使该操作依旧无法继续执行，线程也不会再继续等待下去。 注意： BlockingQueue中是不允许添加null的，该接受在声明的时候就要求所有的实现类在接收到一个null的时候，都应该抛出NullPointerException。(poll在没有数据的时候会返回null)。 123456789 public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue();//当count==0时，返回null &#125; finally &#123; lock.unlock(); &#125;&#125; BlockingQueue是线程安全的，因此它的所有和队列相关的方法都具有原子性。但是对于那么从Collection接口中继承而来的批量操作方法，比如addAll(Collection e)等方法，BlockingQueue的实现通常没有保证其具有原子性，因此我们在使用的BlockingQueue，应该尽可能地不去使用这些方法。 BlockingQueue主要应用于生产者与消费者的模型中，其元素的添加和获取都是极具规律性的。但是对于remove(Object o)这样的方法，虽然BlockingQueue可以保证元素正确的删除，但是这样的操作会非常响应性能，因此我们在没有特殊的情况下，也应该避免使用这类方法。 ArrayBlockingQueue基于数组的并发阻塞队列 构造方法12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 由ReentrantLock实现，公正锁实现，为了保证List的先进先出。除了在内部array未满的时候需要满足先进先出，还需要保证await的线程在signal的时候保证是顺序的（todo condition 源码解析，大致理解是condition内部也是维护一个队列，在signal的时候唤醒的是firstWaiter，这样就能保证线程是顺序唤醒的）。 插入12345678910111213141516171819202122public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) notFull.await(); enqueue(e); &#125; finally &#123; lock.unlock(); &#125;&#125;private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();//为了保证先进先出的效果，需要保证signal是顺序的&#125; 移除12345678910111213141516171819202122232425public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125;private E dequeue() &#123; // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings(&quot;unchecked&quot;) E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued();//删除迭代器中的数据 notFull.signal(); return x;&#125; DelayQueueDelayQueue主要用于放置实现了Delay接口的对象，其中的对象只能在其时刻到期时才能从队列中取走。这种队列是有序的，即队头的延迟到期时间最短。如果没有任何延迟到期，那么久不会有任何头元素。 重点 无界的BlockingQueue poll方法立即返回，如果没有头结点则返回null。take方法会阻塞直到有头结点才返回。代码分析 成员变量1234private final transient ReentrantLock lock = new ReentrantLock();private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();private Thread leader = null;private final Condition available = lock.newCondition(); 内部由优先队列实现，available来控制他的阻塞和通知。lock，还有用于优化阻塞通知的线程元素leader。 offer(E e)1234567891011121314public boolean offer(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; q.offer(e); if (q.peek() == e) &#123; leader = null; available.signal(); &#125; return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 在头元素为空的情况下，插入头元素将会唤醒线程。 take()123456789101112131415161718192021222324252627282930313233public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; E first = q.peek(); if (first == null) available.await();//队列中没有元素的时候，进入等待 else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0) return q.poll(); first = null; // don&apos;t retain ref while waiting if (leader != null) available.await(); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; //用于判断是否有线程在获取 try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; q.peek() != null) available.signal(); lock.unlock(); &#125;&#125; 1first = null; // don&apos;t retain ref while waiting 想想假设现在延迟队列里面有三个对象。 线程A进来获取first,然后进入 else 的else ,设置了leader为当前线程A 线程B进来获取first,进入else的阻塞操作,然后无限期等待 如果线程A阻塞完毕,获取对象成功,出队,这个对象理应被GC回收,但是他还被线程B持有着,GC链可达,所以不能回收这个first. 假设还有线程C 、D、E.. 持有对象1引用,那么无限期的不能回收该对象1引用了,那么就会造成内存泄露. //todo 实现一个带超时的缓存，实现一下delayedQueue LinkedBlockingQueue适合实现一个消费者生产者队列 代码分析12345678910111213private final AtomicInteger count = new AtomicInteger();/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition(); 读写分离，take 和 put 不互斥。ArrayBlockingQueue 为什么只用了一把锁。猜想：ArrayBlockingQueue 是一个环形数组，如果用两把锁，对capacity的判断可能是失效，会导致put的时候插入了存在的数据。而LinkedBlockingQueue 是基于链表的，添加和删除的时候是对于head和last的操作，互不相关，所以可以用两把锁来实现。因为使用了两把锁，所以count使用了AtomicInteger来实现，保证其并发。 offer(E e) 12345678910111213141516171819202122232425262728public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; // int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; if (count.get() &lt; capacity) &#123; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return c &gt;= 0;&#125;private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;//last = head = new Node&lt;E&gt;(null); 初始化的时候head=last，所以在第一个节点插入的时候，head会被赋值&#125; poll 123456789101112131415161718192021222324252627282930313233public E poll() &#123; final AtomicInteger count = this.count; if (count.get() == 0) return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; if (count.get() &gt; 0) &#123; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;private E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125; LinkedTransferQueue//todo PriorityBlockingQueue//todo SynchronousQueue//todo ConcurrentQueue//todo ConcurrentLinkedQueue//todo]]></content>
      <tags>
        <tag>java</tag>
        <tag>复习</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO]]></title>
    <url>%2F2017%2F03%2F29%2FIO%2F</url>
    <content type="text"><![CDATA[Linux IO 模型（详见netty权威指南IO 模型部分）基本概念用户空间和内核空间现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。详解 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 进程阻塞正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。（所以太多的cas会损耗cpu的太多性能？todo） 文件描述符（File descriptor）文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 缓存IO缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 IO模型Linux内核将所有外部设备都看作一个文件来操作，对一个文件的读写会调用 内核 提供的系统命令，返回一个文件描述符(file descriptor)，对一个socket读写也有对应的描述符，叫做socketfd，描述符就是一个数字，指向内核中的一个结构体(内核为各个进程维护的打开文件的记录表) 一次IO操作会将数据先写入内核缓冲区 再将数据转移至进程缓冲区ex: 发生一次read操作后，会发生两件事 等待数据包到达就绪 数据被复制到应用进程的缓冲区 网络应用需要处理的无非就是两大类问题，网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。关于同步非同步 异步非异步的简单理解 同步模型阻塞IO(blocking io)在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图： 非阻塞IO(non-blocking io) 在网络IO时候，非阻塞IO会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，可以重复调用recvfrom进行轮训。 优点：多个任务可以同时执行。 缺点：数据在轮训期间准备完毕，会拉长整个流程的时间，降低吞吐量。 多路复用IO(multiplexing io) IO多路复用有两个特别的系统调用select、poll、epoll（效率更高）函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于， 此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。（单任务全部完成之后才会复制到用户进程，可以同时对多个任务进行操作） I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。 对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了，当然也可以针对不同的编号。具体流程，如下图所示： IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。 在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下： 详见 IO多路复用 信号驱动式IO(signal-driven io)(同步？revfrom是用户进程调用) 首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示： 异步模型异步非阻塞相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。 Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示： 用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。 异步阻塞 有时我们的 API 只提供异步通知方式，例如在 node.js 里，但业务逻辑需要的是做完一件事后做另一件事，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。这样的业务逻辑就需要调用者是以阻塞方式来工作。为了在异步环境里模拟 “顺序执行” 的效果，就需要把同步代码转换成异步形式，这称为 CPS（Continuation Passing Style）变换。BYVoid 大神的 continuation.js 库就是一个 CPS 变换的工具。用户只需用比较符合人类常理的同步方式书写代码，CPS 变换器会把它转换成层层嵌套的异步回调形式。(callback的时候执行剩余逻辑？ 主线程卡死？ 使用回调来返回？) cps相关 另外一种使用阻塞方式的理由是降低响应延迟。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好。 NIO 和 IO的区别区别 IO NIO Stream oriented Buffer oriented Blocking IO Non blocking IO Selectors 概念 IO 阻塞IO 标准IO是面向Stream的，每次从Stream中读取出字节，它不能在流中的数据前后移动，不能说已经读到后面了，再跳到前面去。 Stream是阻塞的，当一个线程调用read或write时，线程是阻塞的，只有等数据读取/写入完成，期间线程不能做任何事。 NIO 非阻塞IO NIO把数据读到一个待处理的Buffer中，也可以在buffer中来回移动，但是不保证Buffer中的数据是所需要的完整数据，需要去校验。 NIO使用一个线程从某个通道中读取数据，但是仅能从Buffer中获得当前的部分数据，而数据变为完整之前，线程并不会被阻塞，而是可以去做其他的事情。写入也是这样，不需要等待它完全写入，就可以去做其他的事情。这里的“其他事情”大部分也是指在其它通道上执行IO操作，所以一个线程可以管理多个输入/输出通道，Selector就是跑在这个线程。 好处：一个Selector能同时对多个Socket连接进行管理。而不会阻塞当前的Selector线程。如果是原有的IO模型，在一个read或者write出现网络问题的时候不能进行下一步的操作，要解决这个问题只能开辟新的线程。这样就会导致线程数太多。而线程池的方案也会有出现多个线程阻塞而拖慢整个系统的问题。类图 例子 1234Name: AnnaAge: 25Email: anna@mailserver.comPhone: 1234567890 IO 12345BufferedReader reader = new BufferedReader(new InputStreamReader(input));String nameLine = reader.readLine();String ageLine = reader.readLine();String emailLine = reader.readLine();String phoneLine = reader.readLine(); NIO 12345ByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = channel.read(buffer);while(! bufferFull(bytesRead) ) &#123; bytesRead = channel.read(buffer);&#125; 需要循环来读取buffer中的所有的值。 NIO实现相关NIO主要的组件有Channel、Buffer、Selector Channel和Buffer和Stream相比，你可以同时对一个Channel进行读和写操作，而Stream只能读或写。 Channel可以异步进行读写。 Channel只和Buffer进行交互。 Channel子类（todo 实现） FileChannel 只能阻塞 详细原因 DatagramChannel 通过UDP 向网络中读写数据 SocketChannel 通过TCP 向网络中读写数据 ServerSocketChannel 允许监听即将到来的TCP连接 12345678910111213141516171819RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;); FileChannel channel = aFile.getChannel(); ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = channel.read(buf); while (bytesRead != -1) &#123; System.out.println(&quot;Read &quot; + bytesRead); buf.flip(); while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); &#125; buf.clear(); bytesRead = channel.read(buf); &#125; aFile.close(); buffer ByteBuffer CharBuffer IntBuffer buffer 属性 position limit capacity 基本用法使用Buffer读写数据一般遵循以下四个步骤： 写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact()方法 Buffer初始化时需要调用各个Buffer的allocate方法，比如CharBuffer cb = CharBuffer.allocate(48); //分配48个char大小的buffer 可以通过buffer.put(x)自己写入数据，也可以调用channel.read把channel中数据写入buffer 可以通过buffer.read()读出数据，也可以channel.write(buf)把buffer中的数据读出来 写入到Channel中 源码分析position和limit的意义在读模式和写模式下是不同的 Invariants: mark &lt;= position &lt;= limit &lt;= capacity（在切换模式和清空buffer的时候都需要重置mark标志位，保证上述关系） filp()flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; rewind()Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。 12345public final Buffer rewind() &#123; position = 0; mark = -1; return this;&#125; clear()与compact()方法一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。 如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。 如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。 123456public final Buffer clear() &#123; position = 0; limit = capacity; mark = -1; return this;&#125; 如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。 compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。（Buffer类中不存在，但是在ByteBuffer中有个抽象方法） 选取DirectByteBuffer实现123456789101112public ByteBuffer compact() &#123; int pos = position(); int lim = limit(); assert (pos &lt;= lim); int rem = (pos &lt;= lim ? lim - pos : 0); unsafe.copyMemory(ix(pos), ix(0), (long)rem &lt;&lt; 0); position(rem); limit(capacity()); discardMark(); return this;&#125; mark()与reset()方法通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如： 123456789101112public final Buffer mark() &#123; mark = position; return this;&#125;public final Buffer reset() &#123; int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this;&#125; Scatter/Gather基本概念 分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。1234ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] byteArray = &#123;header, body&#125;;channel.read(byteArray); 注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。 聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。1234ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] byteArray = &#123;header, body&#125;;channel.write(byteArray); buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。 Selector基本概念 一个线程来操作多个channel，减少上下文开销。Selector的创建1Selector selector = Selector.open(); 向Selector注册通道为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：12channel.configureBlocking(false);SelectionKey key = channel.register(selector,Selectionkey.OP_READ); 与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel（上文有讲）与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。 事件类型有Connect、Accept、Read、Write，都是说这个事件已经ready的时候才触发。如果不止对一种事件感兴趣，可以用“位或”操作符将常量连接起来.1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; SelectionKeyinterest集合1234public static final int OP_READ = 1;public static final int OP_WRITE = 4;public static final int OP_CONNECT = 8;public static final int OP_ACCEPT = 16; 与操作就能判断监听了什么事件类型。 ready集合判断哪些事件已经完成12345int readySet = selectionKey.readyOps();selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); selector + channel12Channel channel = selectionKey.channel();Selector selector = selectionKey.selector(); attachment(附加对象)可以在注册时附加对象，在selectionKey中获取对象1234selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment();SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); 例子12345678910111213141516171819202122Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) &#123; int readyChannels = selector.select(); if(readyChannels == 0) continue; Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839Set&lt;SelectionKey&gt; selectKeys = selector.selectedKeys();Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) &#123;int readyChannels = selector.select();if(readyChannels == 0) continue;Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove();&#125;&#125; nio相关服务端客户端代码 Java I/O模型的演进BIO通信模型当新建一个Socket连接时，由于读/写都是阻塞的，那么就需要一条线程来完成读写操作，即一条线程对应一个Socket连接，如果Socket连接数过多时，线程数过多会导致系统性能下降，栈溢出、创建新线程失败等问题。尝试使用线程池来控制线程资源的数量的方法，但是底层本质上还是阻塞通信，Socket读写在操作完全完成之前，线程会阻塞在I/O操作上，如果 对方发送请求 或者 应答消息 缓慢，或者 网络传输较慢，读写操作所在的线程就会长时间被阻塞，在此期间，其它线程只能在消息队列中排队。比如OutputStream的write操作，线程会被阻塞直到 所有要发送的字节 全部写入完毕，在TCP中，当消息方接受缓慢的时候，不能及时从TCP缓冲区中读出数据，那么发送端就会调整减小window size，写入速度也会越来越慢，此时使用的是阻塞IO，线程就会被阻塞很长时间，如果线程池中所有的线程都被长时间阻塞了，新来的任务就会排队进入任务队列，而任务队列满了之后，再继续提交任务就会导致提交任务的线程阻塞，新的请求会被拒绝，客户端大量超时。（所以适合的超时机制很重要。） 我们无法保证 生产环境的网络状况，对方应用处理速度，如果我们的系统依赖于对方的处理速度，可靠性就无法保证。 NIO通信模型在面向Stream的IO中数据直接写入或读到Steram中，而NIO中，引入了Buffer缓冲区的概念，让Buffer和Channel进行交互。SocketChannel和ServerSocketChannel可以被设置为unblocking的模式，connect/read/write操作不会阻塞当前线程，这样使用selector一个线程管理多个网络IO操作成为可能。Java的NIO使用epoll实现，性能也不会随着客户端增加而下降。 Java 传统IO主要包括字节流和字符流两种Java NIO 和 Netty作为一个NIO服务端，需要能够处理 网络的闪断、客户端的重复接入、客户端的安全认证、消息编解码、半包读写等情况，难度是比较大的。1.Java NIO的API使用起来比较复杂，而netty的api简单，大部分只用关注业务逻辑，灵活扩展。2.必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。3.实现上述的诸多功能工作量和难度较大，而netty做好了封装也很成熟 java iojava io操作类包含在java.io包下，将近80个类，大概分为4组：1.基于字节操作的I/O接口，如InputStream、OutputStream2.基于字符操作的I/O接口，如Reader、Write3.基于磁盘操作的I/O接口，File4.基于网络操作的I/O接口，如Socket前两种是根据传输数据的格式(字节流/字符流)，后两种是传输数据的方式(磁盘/网络) Java 传统IO主要包括字节流和字符流两种 ByteArrayInputStream 12345ByteArrayInputStream &#123; byte[] buf; //inputStream的内容 int pos; //当前读到的位置 int mark; //调用mark标记当前pos，调用reset后可以把pos置回标记的mark处&#125; FileInputStream 对文件的读取，其中大部分的实现调用native完成 FilterInputStream 本身只是把请求委派给内部的InputStream，做一个Decorator，其子类做了各种包装 BufferedInputStream 把内部包装的InputStream读取一些存在一个byte[] buf中，读的时候可以直接中自己的buf中读 DataInputStream 可以读取若干个字节，转换成int、byte、short、UTF字符等类型返回 ObjectInputStream把字节流反序列化为对象，包装内部的一个DataInputStream的数据源，也是一个DecoratorIO流详解]]></content>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wow的岁月]]></title>
    <url>%2F2017%2F03%2F28%2Fwow%E7%9A%84%E5%B2%81%E6%9C%88%2F</url>
    <content type="text"><![CDATA[离开艾泽拉斯很久了，暂时也不能回归，写个文章纪念一下在艾泽拉斯奋战的岁月起 因为wow的第一部CG入坑，直到今天看来，这部CG依旧完爆大部分游戏的CG，当时年幼的我被深深的矮人猎开出的第一枪深深地震撼到了，随即入坑，选择了一个人类女法师，在艾尔文森林愉快地搓起了寒冰箭。 从被霍格追杀，死亡矿井迷路，血色被狗男女灭的死去活来，为了收集荆棘谷的青山在综合频道喊话，东瘟疫之地的爱与家庭，到ZUG,MC,BWL。见到了AL之后再无兄弟，还有象征着主T的荣耀的雷霆之怒，逐风者祝福之剑。 随后跟着朋友在战歌，阿拉希，和奥山疯狂刷荣誉。依稀记得1234冲石炉，56男人，78急救。看着别人穿着一身金光闪闪的大元帅战士羡慕不已。 燃烧的远征开启，穿过黑暗之门来到外域，见到了纳格兰的美丽风景，为了哈兰羊到处刷念珠。永远卡成狗的沙塔斯城。还有屁大点事就能引起团战的奎岛。 现在想来，甚至有点怀念曾经不组队杀不了精英的日子，联盟部落见面就开战，荆棘谷，南海镇，LM,BL野战各种high。 承 因为学习慢慢的远离了wow，错过了WLK还有CTM两个大版本。也是错过了wow最巅峰的时期。在熊猫人之谜前夕受室友感召回归，发现艾泽拉斯的大地已经发生了翻天覆地的变化，转而玩了WLK之前都没有的英雄职业兽人dk（结果发现是个杯具）。 最开始学校网络非常不稳定，只能在杜隆塔尔门口决斗，被战猎焦作人，天神鲁莽震荡波，红人动物园准备就绪再来一套。最初大概只有100胜300负的胜率。随着战猎被砍，跨服决斗的开启，决斗套路越来越熟悉，大概最后到了7500胜1500负的战绩。 在奥尔加隆门口决斗的时候遇见了法师队友阿黄，一个除了吹比啥都不会的亡灵女法师。奶骑“大神”-wcz。还有一个法师转战士的亡者断魂。慢慢的进入了竞技场和评级战场。 评级战场：一个惩戒骑团长带我和麻子的法师遨游1600，随后进入了当时非常仰慕的太极龙带队的评级团，4战2dk最后大概定格在2800左右的评级吧。 竞技场：和wcz，亡者断魂，三板一个下午2199，最后因为战士掉线三把，回到2000，因为排不到队伍，也没有队友，奶骑怒而afk。第一赛季3v3定格在了2199。 转 5.2开启，寝室一众人转去了19组安苏LM，恰逢鹦鹉贼+8800sp无比强势，捡起了TBC的骑士号，贼骑朝着2200飞奔而去，无奈法牧版本。贼骑最终止步2000。在此期间认识了面向大海（通信学院学弟），阿七（一个除了吹比啥都不会的ss），十月（军需官面前认识的万年cjq），买糖（国服最强的竞争者萨满），最终都成为了日后的队友。同时，看了hydra的视频，恰逢ms强势版本，转行玩ms，和阿黄开始了法牧生涯。 5.3鹦鹉贼削弱，22贼牧再次起飞，止步2150，和兰服猎人无涯和兔子惩猎牧经过2小时的厮杀冲破2200，接近2400，随后兔子afk，借了个小号打起了毫无希望的贼猎牧，没想到一路横冲直撞冲上了2400，怒把自己的号退队一起打贼猎牧，队友全都获得了2400成就，然而我的分数最终定格2398，再也没有上分。55同时开打，贼法猎惩牧（麻子，阿黄，无涯，十月），4dd在21组横行，最高55 21组第二。22在此期间也成功通过法牧上了2200，获得竞技场大师成就，获得决斗者。 LM 33贼法牧也逐渐成型，在暴虐结算当天的前一天开打，两个晚上接近70%胜率接近2400。打的同工会的3板悲伤的下线，死磕战法牧，最终因为网络原因定格2397。也算是一个遗憾吧，两个号都没有获得2400成就。 5.4 一开始法术骑和贼法牧就同时获得了3v3 2700成就。55法三远（阿黄，阿七，天才高中生 张良，鸽王 味陌）也是一路高胜率2700。22 也在那个赛季打到了2700+，算是挺圆满的，就差一个斗士了。 5.x版本是个充斥着刷分的版本，认识了很多新朋友，因为刷子很多人再也没有回到wow。合 6.0开服之后顺利的拿到了斗士，也算是一种圆满吧。贼法德玩的很开心，惩戒骑也上过评级第一页，虽然没拿到英雄，但是好像已经不在意那些事情了，面临毕业，还有很多重要的事情需要去完成，慢慢地淡出了wow，感谢在艾泽拉斯的那段岁月。 感谢很多没有提到的朋友，nga美少女–艾琳.冰冻丢墙上.纳斯，评级牧神–Slience，逗比奶僧–咸鱼，我吃个饭就回来–萌萌的喵喵.微娘。还有竹爷，羊哥，Smudgelol，Sinsin，EE，耗子，杀生 等等。 最后，鲜血与荣耀，为了部落！Lok-tar ogar! 电子设备换了一波又一波，没有图了。最后上个图吧~]]></content>
      <tags>
        <tag>wow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree Traversal]]></title>
    <url>%2F2017%2F03%2F27%2FTree-Traversal%2F</url>
    <content type="text"><![CDATA[pre order Pre-order: F, B, A, D, C, E, G, I, H. Check if the current node is empty / null Display the data part of the root (or current node). Traverse the left subtree by recursively calling the pre-order function. Traverse the right subtree by recursively calling the pre-order function. 1234567891011121314public class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;(); if(root!=null) s.push(root); while(!s.isEmpty())&#123; TreeNode curr = s.pop(); res.add(curr.val); if(curr.right!=null) s.push(curr.right); if(curr.left!=null) s.push(curr.left); &#125; return res; &#125;&#125; in order In-order: A, B, C, D, E, F, G, H, I. Check if the current node is empty / null Traverse the left subtree by recursively calling the in-order function. Display the data part of the root (or current node). Traverse the right subtree by recursively calling the in-order function. In a search tree, in-order traversal retrieves data in sorted order. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); //先将最左边的节点都push进栈 if(root!=null)&#123; pushAllTheLeft(s, root); &#125; while(!s.isEmpty())&#123; TreeNode curr = s.pop(); res.add(curr.val); //如果有右子树，将右节点和右子树的最左边的节点都push进栈 if(curr.right != null)&#123; pushAllTheLeft(s, curr.right); &#125; &#125; return res; &#125; private void pushAllTheLeft(Stack&lt;TreeNode&gt; s, TreeNode root)&#123; s.push(root); while(root.left!=null)&#123; root = root.left; s.push(root); &#125; &#125;&#125; post order Post-order: A, C, E, D, B, H, I, G, F. Check if the current node is empty / null Traverse the left subtree by recursively calling the post-order function. Traverse the right subtree by recursively calling the post-order function. Display the data part of the root (or current node). The trace of a traversal is called a sequentialisation of the tree. The traversal trace is a list of each visited root. No one sequentialisation according to pre-, in- or post-order describes the underlying tree uniquely. Given a tree with distinct elements, either pre-order or post-order paired with in-order is sufficient to describe the tree uniquely. However, pre-order with post-order leaves some ambiguity in the tree structure. 123456789101112131415161718192021222324252627282930 public class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; Stack&lt;PowerNode&gt; s = new Stack&lt;PowerNode&gt;(); List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;(); if(root!=null) s.push(new PowerNode(root, false)); while(!s.isEmpty())&#123; PowerNode curr = s.peek(); //如果是第二次访问，就计算并pop该节点 if(curr.visited)&#123; res.add(curr.node.val); s.pop(); &#125; else &#123; //如果是第一次访问，就将它的左右节点加入stack，并设置其已经访问了一次 if(curr.node.right!=null) s.push(new PowerNode(curr.node.right, false)); if(curr.node.left!=null) s.push(new PowerNode(curr.node.left, false)); curr.visited = true; &#125; &#125; return res; &#125; private class PowerNode &#123; TreeNode node; boolean visited; public PowerNode(TreeNode n, boolean v)&#123; this.node = n; this.visited = v; &#125; &#125;&#125; 参见wiki 参见[leetcode] Binary Tree Traversal 二叉树遍历]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>